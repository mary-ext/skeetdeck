// This file is automatically generated, do not edit!

export declare namespace Brand {
	const Type: unique symbol;

	type GetType<T extends { [Type]?: string }> = NonNullable<T[typeof Type]>;

	type Union<T extends { [Type]?: string }> = T extends any ? T & { $type: GetType<T> } : never;
}

export declare namespace At {
	type CID = string;

	type DID = `did:${string}`;

	type Handle = string;

	type Uri = string;

	interface Blob<T extends string = string> {
		[Brand.Type]?: 'blob';
		mimeType: T;
		ref: {
			$link: string;
		};
		size: number;
	}
}
export declare namespace AppBskyActorDefs {
	interface ProfileViewBasic {
		[Brand.Type]?: 'app.bsky.actor.defs#profileViewBasic';
		did: At.DID;
		handle: At.Handle;
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		avatar?: string;
		viewer?: ViewerState;
		labels?: ComAtprotoLabelDefs.Label[];
	}
	interface ProfileView {
		[Brand.Type]?: 'app.bsky.actor.defs#profileView';
		did: At.DID;
		handle: At.Handle;
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		/**
		 * Maximum string length: 2560 \
		 * Maximum grapheme length: 256
		 */
		description?: string;
		avatar?: string;
		indexedAt?: string;
		viewer?: ViewerState;
		labels?: ComAtprotoLabelDefs.Label[];
	}
	interface ProfileViewDetailed {
		[Brand.Type]?: 'app.bsky.actor.defs#profileViewDetailed';
		did: At.DID;
		handle: At.Handle;
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		/**
		 * Maximum string length: 2560 \
		 * Maximum grapheme length: 256
		 */
		description?: string;
		avatar?: string;
		banner?: string;
		followersCount?: number;
		followsCount?: number;
		postsCount?: number;
		indexedAt?: string;
		viewer?: ViewerState;
		labels?: ComAtprotoLabelDefs.Label[];
	}
	/** Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests. */
	interface ViewerState {
		[Brand.Type]?: 'app.bsky.actor.defs#viewerState';
		muted?: boolean;
		mutedByList?: AppBskyGraphDefs.ListViewBasic;
		blockedBy?: boolean;
		blocking?: At.Uri;
		blockingByList?: AppBskyGraphDefs.ListViewBasic;
		following?: At.Uri;
		followedBy?: At.Uri;
	}
	type Preferences = Brand.Union<
		| AdultContentPref
		| ContentLabelPref
		| SavedFeedsPref
		| PersonalDetailsPref
		| FeedViewPref
		| ThreadViewPref
		| InterestsPref
		| MutedWordsPref
		| HiddenPostsPref
	>[];
	interface AdultContentPref {
		[Brand.Type]?: 'app.bsky.actor.defs#adultContentPref';
		/** @default false */
		enabled: boolean;
	}
	interface ContentLabelPref {
		[Brand.Type]?: 'app.bsky.actor.defs#contentLabelPref';
		label: string;
		visibility: 'show' | 'warn' | 'hide' | (string & {});
	}
	interface SavedFeedsPref {
		[Brand.Type]?: 'app.bsky.actor.defs#savedFeedsPref';
		pinned: At.Uri[];
		saved: At.Uri[];
		timelineIndex?: number;
	}
	interface PersonalDetailsPref {
		[Brand.Type]?: 'app.bsky.actor.defs#personalDetailsPref';
		/** The birth date of account owner. */
		birthDate?: string;
	}
	interface FeedViewPref {
		[Brand.Type]?: 'app.bsky.actor.defs#feedViewPref';
		/** The URI of the feed, or an identifier which describes the feed. */
		feed: string;
		/** Hide replies in the feed. */
		hideReplies?: boolean;
		/** Hide replies in the feed if they are not by followed users. */
		hideRepliesByUnfollowed?: boolean;
		/** Hide replies in the feed if they do not have this number of likes. */
		hideRepliesByLikeCount?: number;
		/** Hide reposts in the feed. */
		hideReposts?: boolean;
		/** Hide quote posts in the feed. */
		hideQuotePosts?: boolean;
	}
	interface ThreadViewPref {
		[Brand.Type]?: 'app.bsky.actor.defs#threadViewPref';
		/** Sorting mode for threads. */
		sort?: 'oldest' | 'newest' | 'most-likes' | 'random' | (string & {});
		/** Show followed users at the top of all replies. */
		prioritizeFollowedUsers?: boolean;
	}
	interface InterestsPref {
		[Brand.Type]?: 'app.bsky.actor.defs#interestsPref';
		/**
		 * A list of tags which describe the account owner's interests gathered during onboarding. \
		 * Maximum array length: 100 \
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		tags: string[];
	}
	/**
	 * Maximum string length: 640 \
	 * Maximum grapheme length: 64
	 */
	type MutedWordTarget = 'content' | 'tag' | (string & {});
	/** A word that the account owner has muted. */
	interface MutedWord {
		[Brand.Type]?: 'app.bsky.actor.defs#mutedWord';
		/**
		 * The muted word itself. \
		 * Maximum string length: 10000 \
		 * Maximum grapheme length: 1000
		 */
		value: string;
		/** The intended targets of the muted word. */
		targets: AppBskyActorDefs.MutedWordTarget[];
	}
	interface MutedWordsPref {
		[Brand.Type]?: 'app.bsky.actor.defs#mutedWordsPref';
		/** A list of words the account owner has muted. */
		items: AppBskyActorDefs.MutedWord[];
	}
	interface HiddenPostsPref {
		[Brand.Type]?: 'app.bsky.actor.defs#hiddenPostsPref';
		/** A list of URIs of posts the account owner has hidden. */
		items: At.Uri[];
	}
}

/** Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth. */
export declare namespace AppBskyActorGetPreferences {
	interface Params {}
	type Input = undefined;
	interface Output {
		preferences: AppBskyActorDefs.Preferences;
	}
}

/** Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth. */
export declare namespace AppBskyActorGetProfile {
	interface Params {
		/** Handle or DID of account to fetch profile of. */
		actor: string;
	}
	type Input = undefined;
	type Output = AppBskyActorDefs.ProfileViewDetailed;
}

/** Get detailed profile views of multiple actors. */
export declare namespace AppBskyActorGetProfiles {
	interface Params {
		/** Maximum array length: 25 */
		actors: string[];
	}
	type Input = undefined;
	interface Output {
		profiles: AppBskyActorDefs.ProfileViewDetailed[];
	}
}

/** Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding. */
export declare namespace AppBskyActorGetSuggestions {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		actors: AppBskyActorDefs.ProfileView[];
	}
}

export declare namespace AppBskyActorProfile {
	interface Record {
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		/**
		 * Free-form profile description text. \
		 * Maximum string length: 2560 \
		 * Maximum grapheme length: 256
		 */
		description?: string;
		/** Small image to be displayed next to posts from account. AKA, 'profile picture' */
		avatar?: At.Blob<`image/png` | `image/jpeg`>;
		/** Larger horizontal image to display behind profile view. */
		banner?: At.Blob<`image/png` | `image/jpeg`>;
		/** Self-label values, specific to the Bluesky application, on the overall account. */
		labels?: Brand.Union<ComAtprotoLabelDefs.SelfLabels>;
	}
}

/** Set the private preferences attached to the account. */
export declare namespace AppBskyActorPutPreferences {
	interface Params {}
	interface Input {
		preferences: AppBskyActorDefs.Preferences;
	}
	type Output = undefined;
}

/** Find actors (profiles) matching search criteria. Does not require auth. */
export declare namespace AppBskyActorSearchActors {
	interface Params {
		/**
		 * DEPRECATED: use 'q' instead.
		 * @deprecated
		 */
		term?: string;
		/** Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
		q?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 25
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		actors: AppBskyActorDefs.ProfileView[];
	}
}

/** Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth. */
export declare namespace AppBskyActorSearchActorsTypeahead {
	interface Params {
		/**
		 * DEPRECATED: use 'q' instead.
		 * @deprecated
		 */
		term?: string;
		/** Search query prefix; not a full query string. */
		q?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 10
		 */
		limit?: number;
	}
	type Input = undefined;
	interface Output {
		actors: AppBskyActorDefs.ProfileViewBasic[];
	}
}

export declare namespace AppBskyEmbedExternal {
	/** A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post). */
	interface Main {
		[Brand.Type]?: 'app.bsky.embed.external';
		external: External;
	}
	interface External {
		[Brand.Type]?: 'app.bsky.embed.external#external';
		uri: string;
		title: string;
		description: string;
		thumb?: At.Blob<`image/${string}`>;
	}
	interface View {
		[Brand.Type]?: 'app.bsky.embed.external#view';
		external: ViewExternal;
	}
	interface ViewExternal {
		[Brand.Type]?: 'app.bsky.embed.external#viewExternal';
		uri: string;
		title: string;
		description: string;
		thumb?: string;
	}
}

export declare namespace AppBskyEmbedImages {
	interface Main {
		[Brand.Type]?: 'app.bsky.embed.images';
		/** Maximum array length: 4 */
		images: Image[];
	}
	interface Image {
		[Brand.Type]?: 'app.bsky.embed.images#image';
		image: At.Blob<`image/${string}`>;
		/** Alt text description of the image, for accessibility. */
		alt: string;
		aspectRatio?: AspectRatio;
	}
	/** width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit. */
	interface AspectRatio {
		[Brand.Type]?: 'app.bsky.embed.images#aspectRatio';
		/** Minimum: 1 */
		width: number;
		/** Minimum: 1 */
		height: number;
	}
	interface View {
		[Brand.Type]?: 'app.bsky.embed.images#view';
		/** Maximum array length: 4 */
		images: ViewImage[];
	}
	interface ViewImage {
		[Brand.Type]?: 'app.bsky.embed.images#viewImage';
		/** Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View. */
		thumb: string;
		/** Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View. */
		fullsize: string;
		/** Alt text description of the image, for accessibility. */
		alt: string;
		aspectRatio?: AspectRatio;
	}
}

export declare namespace AppBskyEmbedRecord {
	interface Main {
		[Brand.Type]?: 'app.bsky.embed.record';
		record: ComAtprotoRepoStrongRef.Main;
	}
	interface View {
		[Brand.Type]?: 'app.bsky.embed.record#view';
		record: Brand.Union<
			ViewRecord | ViewNotFound | ViewBlocked | AppBskyFeedDefs.GeneratorView | AppBskyGraphDefs.ListView
		>;
	}
	interface ViewRecord {
		[Brand.Type]?: 'app.bsky.embed.record#viewRecord';
		uri: At.Uri;
		cid: At.CID;
		author: AppBskyActorDefs.ProfileViewBasic;
		/** The record data itself. */
		value: unknown;
		labels?: ComAtprotoLabelDefs.Label[];
		embeds?: Brand.Union<
			| AppBskyEmbedImages.View
			| AppBskyEmbedExternal.View
			| AppBskyEmbedRecord.View
			| AppBskyEmbedRecordWithMedia.View
		>[];
		indexedAt: string;
	}
	interface ViewNotFound {
		[Brand.Type]?: 'app.bsky.embed.record#viewNotFound';
		uri: At.Uri;
		notFound: boolean;
	}
	interface ViewBlocked {
		[Brand.Type]?: 'app.bsky.embed.record#viewBlocked';
		uri: At.Uri;
		blocked: boolean;
		author: AppBskyFeedDefs.BlockedAuthor;
	}
}

export declare namespace AppBskyEmbedRecordWithMedia {
	interface Main {
		[Brand.Type]?: 'app.bsky.embed.recordWithMedia';
		record: AppBskyEmbedRecord.Main;
		media: Brand.Union<AppBskyEmbedImages.Main | AppBskyEmbedExternal.Main>;
	}
	interface View {
		[Brand.Type]?: 'app.bsky.embed.recordWithMedia#view';
		record: AppBskyEmbedRecord.View;
		media: Brand.Union<AppBskyEmbedImages.View | AppBskyEmbedExternal.View>;
	}
}

export declare namespace AppBskyFeedDefs {
	interface PostView {
		[Brand.Type]?: 'app.bsky.feed.defs#postView';
		uri: At.Uri;
		cid: At.CID;
		author: AppBskyActorDefs.ProfileViewBasic;
		record: unknown;
		embed?: Brand.Union<
			| AppBskyEmbedImages.View
			| AppBskyEmbedExternal.View
			| AppBskyEmbedRecord.View
			| AppBskyEmbedRecordWithMedia.View
		>;
		replyCount?: number;
		repostCount?: number;
		likeCount?: number;
		indexedAt: string;
		viewer?: ViewerState;
		labels?: ComAtprotoLabelDefs.Label[];
		threadgate?: ThreadgateView;
	}
	/** Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests. */
	interface ViewerState {
		[Brand.Type]?: 'app.bsky.feed.defs#viewerState';
		repost?: At.Uri;
		like?: At.Uri;
		replyDisabled?: boolean;
	}
	interface FeedViewPost {
		[Brand.Type]?: 'app.bsky.feed.defs#feedViewPost';
		post: PostView;
		reply?: ReplyRef;
		reason?: Brand.Union<ReasonRepost>;
	}
	interface ReplyRef {
		[Brand.Type]?: 'app.bsky.feed.defs#replyRef';
		root: Brand.Union<PostView | NotFoundPost | BlockedPost>;
		parent: Brand.Union<PostView | NotFoundPost | BlockedPost>;
	}
	interface ReasonRepost {
		[Brand.Type]?: 'app.bsky.feed.defs#reasonRepost';
		by: AppBskyActorDefs.ProfileViewBasic;
		indexedAt: string;
	}
	interface ThreadViewPost {
		[Brand.Type]?: 'app.bsky.feed.defs#threadViewPost';
		post: PostView;
		parent?: Brand.Union<ThreadViewPost | NotFoundPost | BlockedPost>;
		replies?: Brand.Union<ThreadViewPost | NotFoundPost | BlockedPost>[];
	}
	interface NotFoundPost {
		[Brand.Type]?: 'app.bsky.feed.defs#notFoundPost';
		uri: At.Uri;
		notFound: boolean;
	}
	interface BlockedPost {
		[Brand.Type]?: 'app.bsky.feed.defs#blockedPost';
		uri: At.Uri;
		blocked: boolean;
		author: BlockedAuthor;
	}
	interface BlockedAuthor {
		[Brand.Type]?: 'app.bsky.feed.defs#blockedAuthor';
		did: At.DID;
		viewer?: AppBskyActorDefs.ViewerState;
	}
	interface GeneratorView {
		[Brand.Type]?: 'app.bsky.feed.defs#generatorView';
		uri: At.Uri;
		cid: At.CID;
		did: At.DID;
		creator: AppBskyActorDefs.ProfileView;
		displayName: string;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: AppBskyRichtextFacet.Main[];
		avatar?: string;
		/** Minimum: 0 */
		likeCount?: number;
		viewer?: GeneratorViewerState;
		indexedAt: string;
	}
	interface GeneratorViewerState {
		[Brand.Type]?: 'app.bsky.feed.defs#generatorViewerState';
		like?: At.Uri;
	}
	interface SkeletonFeedPost {
		[Brand.Type]?: 'app.bsky.feed.defs#skeletonFeedPost';
		post: At.Uri;
		reason?: Brand.Union<SkeletonReasonRepost>;
	}
	interface SkeletonReasonRepost {
		[Brand.Type]?: 'app.bsky.feed.defs#skeletonReasonRepost';
		repost: At.Uri;
	}
	interface ThreadgateView {
		[Brand.Type]?: 'app.bsky.feed.defs#threadgateView';
		uri?: At.Uri;
		cid?: At.CID;
		record?: unknown;
		lists?: AppBskyGraphDefs.ListViewBasic[];
	}
}

/** Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View). */
export declare namespace AppBskyFeedDescribeFeedGenerator {
	interface Params {}
	type Input = undefined;
	interface Output {
		did: At.DID;
		feeds: Feed[];
		links?: Links;
	}
	interface Feed {
		[Brand.Type]?: 'app.bsky.feed.describeFeedGenerator#feed';
		uri: At.Uri;
	}
	interface Links {
		[Brand.Type]?: 'app.bsky.feed.describeFeedGenerator#links';
		privacyPolicy?: string;
		termsOfService?: string;
	}
}

export declare namespace AppBskyFeedGenerator {
	interface Record {
		did: At.DID;
		/**
		 * Maximum string length: 240 \
		 * Maximum grapheme length: 24
		 */
		displayName: string;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: AppBskyRichtextFacet.Main[];
		avatar?: At.Blob<`image/png` | `image/jpeg`>;
		/** Self-label values */
		labels?: Brand.Union<ComAtprotoLabelDefs.SelfLabels>;
		createdAt: string;
	}
}

/** Get a list of feeds (feed generator records) created by the actor (in the actor's repo). */
export declare namespace AppBskyFeedGetActorFeeds {
	interface Params {
		actor: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		feeds: AppBskyFeedDefs.GeneratorView[];
	}
}

/** Get a list of posts liked by an actor. Does not require auth. */
export declare namespace AppBskyFeedGetActorLikes {
	interface Params {
		actor: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		feed: AppBskyFeedDefs.FeedViewPost[];
	}
	interface Errors {
		BlockedActor: {};
		BlockedByActor: {};
	}
}

/** Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth. */
export declare namespace AppBskyFeedGetAuthorFeed {
	interface Params {
		actor: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
		/**
		 * Combinations of post/repost types to include in response.
		 * @default "posts_with_replies"
		 */
		filter?:
			| 'posts_with_replies'
			| 'posts_no_replies'
			| 'posts_with_media'
			| 'posts_and_author_threads'
			| (string & {});
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		feed: AppBskyFeedDefs.FeedViewPost[];
	}
	interface Errors {
		BlockedActor: {};
		BlockedByActor: {};
	}
}

/** Get a hydrated feed from an actor's selected feed generator. Implemented by App View. */
export declare namespace AppBskyFeedGetFeed {
	interface Params {
		feed: At.Uri;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		feed: AppBskyFeedDefs.FeedViewPost[];
	}
	interface Errors {
		UnknownFeed: {};
	}
}

/** Get information about a feed generator. Implemented by AppView. */
export declare namespace AppBskyFeedGetFeedGenerator {
	interface Params {
		/** AT-URI of the feed generator record. */
		feed: At.Uri;
	}
	type Input = undefined;
	interface Output {
		view: AppBskyFeedDefs.GeneratorView;
		/** Indicates whether the feed generator service has been online recently, or else seems to be inactive. */
		isOnline: boolean;
		/** Indicates whether the feed generator service is compatible with the record declaration. */
		isValid: boolean;
	}
}

/** Get information about a list of feed generators. */
export declare namespace AppBskyFeedGetFeedGenerators {
	interface Params {
		feeds: At.Uri[];
	}
	type Input = undefined;
	interface Output {
		feeds: AppBskyFeedDefs.GeneratorView[];
	}
}

/** Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service. */
export declare namespace AppBskyFeedGetFeedSkeleton {
	interface Params {
		/** Reference to feed generator record describing the specific feed being requested. */
		feed: At.Uri;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		feed: AppBskyFeedDefs.SkeletonFeedPost[];
	}
	interface Errors {
		UnknownFeed: {};
	}
}

/** Get like records which reference a subject (by AT-URI and CID). */
export declare namespace AppBskyFeedGetLikes {
	interface Params {
		/** AT-URI of the subject (eg, a post record). */
		uri: At.Uri;
		/** CID of the subject record (aka, specific version of record), to filter likes. */
		cid?: At.CID;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		uri: At.Uri;
		cid?: At.CID;
		cursor?: string;
		likes: Like[];
	}
	interface Like {
		[Brand.Type]?: 'app.bsky.feed.getLikes#like';
		indexedAt: string;
		createdAt: string;
		actor: AppBskyActorDefs.ProfileView;
	}
}

/** Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth. */
export declare namespace AppBskyFeedGetListFeed {
	interface Params {
		/** Reference (AT-URI) to the list record. */
		list: At.Uri;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		feed: AppBskyFeedDefs.FeedViewPost[];
	}
	interface Errors {
		UnknownList: {};
	}
}

/** Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests. */
export declare namespace AppBskyFeedGetPostThread {
	interface Params {
		/** Reference (AT-URI) to post record. */
		uri: At.Uri;
		/**
		 * How many levels of reply depth should be included in response. \
		 * Minimum: 0 \
		 * Maximum: 1000
		 * @default 6
		 */
		depth?: number;
		/**
		 * How many levels of parent (and grandparent, etc) post to include. \
		 * Minimum: 0 \
		 * Maximum: 1000
		 * @default 80
		 */
		parentHeight?: number;
	}
	type Input = undefined;
	interface Output {
		thread: Brand.Union<
			AppBskyFeedDefs.ThreadViewPost | AppBskyFeedDefs.NotFoundPost | AppBskyFeedDefs.BlockedPost
		>;
	}
	interface Errors {
		NotFound: {};
	}
}

/** Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'. */
export declare namespace AppBskyFeedGetPosts {
	interface Params {
		/**
		 * List of post AT-URIs to return hydrated views for. \
		 * Maximum array length: 25
		 */
		uris: At.Uri[];
	}
	type Input = undefined;
	interface Output {
		posts: AppBskyFeedDefs.PostView[];
	}
}

/** Get a list of reposts for a given post. */
export declare namespace AppBskyFeedGetRepostedBy {
	interface Params {
		/** Reference (AT-URI) of post record */
		uri: At.Uri;
		/** If supplied, filters to reposts of specific version (by CID) of the post record. */
		cid?: At.CID;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		uri: At.Uri;
		cid?: At.CID;
		cursor?: string;
		repostedBy: AppBskyActorDefs.ProfileView[];
	}
}

/** Get a list of suggested feeds (feed generators) for the requesting account. */
export declare namespace AppBskyFeedGetSuggestedFeeds {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		feeds: AppBskyFeedDefs.GeneratorView[];
	}
}

/** Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed. */
export declare namespace AppBskyFeedGetTimeline {
	interface Params {
		/** Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism. */
		algorithm?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		feed: AppBskyFeedDefs.FeedViewPost[];
	}
}

export declare namespace AppBskyFeedLike {
	interface Record {
		subject: ComAtprotoRepoStrongRef.Main;
		createdAt: string;
	}
}

export declare namespace AppBskyFeedPost {
	interface Record {
		/**
		 * The primary post content. May be an empty string, if there are embeds. \
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		text: string;
		/**
		 * DEPRECATED: replaced by app.bsky.richtext.facet.
		 * @deprecated
		 */
		entities?: Entity[];
		/** Annotations of text (mentions, URLs, hashtags, etc) */
		facets?: AppBskyRichtextFacet.Main[];
		reply?: ReplyRef;
		embed?: Brand.Union<
			| AppBskyEmbedImages.Main
			| AppBskyEmbedExternal.Main
			| AppBskyEmbedRecord.Main
			| AppBskyEmbedRecordWithMedia.Main
		>;
		/**
		 * Indicates human language of post primary text content. \
		 * Maximum array length: 3
		 */
		langs?: string[];
		/** Self-label values for this post. Effectively content warnings. */
		labels?: Brand.Union<ComAtprotoLabelDefs.SelfLabels>;
		/**
		 * Additional hashtags, in addition to any included in post text and facets. \
		 * Maximum array length: 8 \
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		tags?: string[];
		/** Client-declared timestamp when this post was originally created. */
		createdAt: string;
	}
	interface ReplyRef {
		[Brand.Type]?: 'app.bsky.feed.post#replyRef';
		root: ComAtprotoRepoStrongRef.Main;
		parent: ComAtprotoRepoStrongRef.Main;
	}
	/**
	 * Deprecated: use facets instead.
	 * @deprecated
	 */
	interface Entity {
		[Brand.Type]?: 'app.bsky.feed.post#entity';
		index: TextSlice;
		/** Expected values are 'mention' and 'link'. */
		type: string;
		value: string;
	}
	/**
	 * Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.
	 * @deprecated
	 */
	interface TextSlice {
		[Brand.Type]?: 'app.bsky.feed.post#textSlice';
		/** Minimum: 0 */
		start: number;
		/** Minimum: 0 */
		end: number;
	}
}

export declare namespace AppBskyFeedRepost {
	interface Record {
		subject: ComAtprotoRepoStrongRef.Main;
		createdAt: string;
	}
}

/** Find posts matching search criteria, returning views of those posts. */
export declare namespace AppBskyFeedSearchPosts {
	interface Params {
		/** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
		q: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 25
		 */
		limit?: number;
		/** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		/** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
		hitsTotal?: number;
		posts: AppBskyFeedDefs.PostView[];
	}
	interface Errors {
		BadQueryString: {};
	}
}

export declare namespace AppBskyFeedThreadgate {
	interface Record {
		/** Reference (AT-URI) to the post record. */
		post: At.Uri;
		/** Maximum array length: 5 */
		allow?: Brand.Union<MentionRule | FollowingRule | ListRule>[];
		createdAt: string;
	}
	/** Allow replies from actors mentioned in your post. */
	interface MentionRule {
		[Brand.Type]?: 'app.bsky.feed.threadgate#mentionRule';
	}
	/** Allow replies from actors you follow. */
	interface FollowingRule {
		[Brand.Type]?: 'app.bsky.feed.threadgate#followingRule';
	}
	/** Allow replies from actors on a list. */
	interface ListRule {
		[Brand.Type]?: 'app.bsky.feed.threadgate#listRule';
		list: At.Uri;
	}
}

export declare namespace AppBskyGraphBlock {
	interface Record {
		/** DID of the account to be blocked. */
		subject: At.DID;
		createdAt: string;
	}
}

export declare namespace AppBskyGraphDefs {
	interface ListViewBasic {
		[Brand.Type]?: 'app.bsky.graph.defs#listViewBasic';
		uri: At.Uri;
		cid: At.CID;
		/**
		 * Minimum string length: 1 \
		 * Maximum string length: 64
		 */
		name: string;
		purpose: ListPurpose;
		avatar?: string;
		viewer?: ListViewerState;
		indexedAt?: string;
	}
	interface ListView {
		[Brand.Type]?: 'app.bsky.graph.defs#listView';
		uri: At.Uri;
		cid: At.CID;
		creator: AppBskyActorDefs.ProfileView;
		/**
		 * Minimum string length: 1 \
		 * Maximum string length: 64
		 */
		name: string;
		purpose: ListPurpose;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: AppBskyRichtextFacet.Main[];
		avatar?: string;
		viewer?: ListViewerState;
		indexedAt: string;
	}
	interface ListItemView {
		[Brand.Type]?: 'app.bsky.graph.defs#listItemView';
		uri: At.Uri;
		subject: AppBskyActorDefs.ProfileView;
	}
	type ListPurpose = 'app.bsky.graph.defs#modlist' | 'app.bsky.graph.defs#curatelist' | (string & {});
	type Modlist = 'app.bsky.graph.defs#modlist';
	type Curatelist = 'app.bsky.graph.defs#curatelist';
	interface ListViewerState {
		[Brand.Type]?: 'app.bsky.graph.defs#listViewerState';
		muted?: boolean;
		blocked?: At.Uri;
	}
	/** indicates that a handle or DID could not be resolved */
	interface NotFoundActor {
		[Brand.Type]?: 'app.bsky.graph.defs#notFoundActor';
		actor: string;
		notFound: boolean;
	}
	/** lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object) */
	interface Relationship {
		[Brand.Type]?: 'app.bsky.graph.defs#relationship';
		did: At.DID;
		/** if the actor follows this DID, this is the AT-URI of the follow record */
		following?: At.Uri;
		/** if the actor is followed by this DID, contains the AT-URI of the follow record */
		followedBy?: At.Uri;
	}
}

export declare namespace AppBskyGraphFollow {
	interface Record {
		subject: At.DID;
		createdAt: string;
	}
}

/** Enumerates which accounts the requesting account is currently blocking. Requires auth. */
export declare namespace AppBskyGraphGetBlocks {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		blocks: AppBskyActorDefs.ProfileView[];
	}
}

/** Enumerates accounts which follow a specified account (actor). */
export declare namespace AppBskyGraphGetFollowers {
	interface Params {
		actor: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		subject: AppBskyActorDefs.ProfileView;
		cursor?: string;
		followers: AppBskyActorDefs.ProfileView[];
	}
}

/** Enumerates accounts which a specified account (actor) follows. */
export declare namespace AppBskyGraphGetFollows {
	interface Params {
		actor: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		subject: AppBskyActorDefs.ProfileView;
		cursor?: string;
		follows: AppBskyActorDefs.ProfileView[];
	}
}

/** Gets a 'view' (with additional context) of a specified list. */
export declare namespace AppBskyGraphGetList {
	interface Params {
		/** Reference (AT-URI) of the list record to hydrate. */
		list: At.Uri;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		list: AppBskyGraphDefs.ListView;
		items: AppBskyGraphDefs.ListItemView[];
	}
}

/** Get mod lists that the requesting account (actor) is blocking. Requires auth. */
export declare namespace AppBskyGraphGetListBlocks {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		lists: AppBskyGraphDefs.ListView[];
	}
}

/** Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth. */
export declare namespace AppBskyGraphGetListMutes {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		lists: AppBskyGraphDefs.ListView[];
	}
}

/** Enumerates the lists created by a specified account (actor). */
export declare namespace AppBskyGraphGetLists {
	interface Params {
		/** The account (actor) to enumerate lists from. */
		actor: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		lists: AppBskyGraphDefs.ListView[];
	}
}

/** Enumerates accounts that the requesting account (actor) currently has muted. Requires auth. */
export declare namespace AppBskyGraphGetMutes {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		mutes: AppBskyActorDefs.ProfileView[];
	}
}

/** Enumerates public relationships between one account, and a list of other accounts. Does not require auth. */
export declare namespace AppBskyGraphGetRelationships {
	interface Params {
		/** Primary account requesting relationships for. */
		actor: string;
		/**
		 * List of 'other' accounts to be related back to the primary. \
		 * Maximum array length: 30
		 */
		others?: string[];
	}
	type Input = undefined;
	interface Output {
		actor?: At.DID;
		relationships: Brand.Union<AppBskyGraphDefs.Relationship | AppBskyGraphDefs.NotFoundActor>[];
	}
	interface Errors {
		ActorNotFound: {};
	}
}

/** Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account. */
export declare namespace AppBskyGraphGetSuggestedFollowsByActor {
	interface Params {
		actor: string;
	}
	type Input = undefined;
	interface Output {
		suggestions: AppBskyActorDefs.ProfileView[];
	}
}

export declare namespace AppBskyGraphList {
	interface Record {
		/** Defines the purpose of the list (aka, moderation-oriented or curration-oriented) */
		purpose: AppBskyGraphDefs.ListPurpose;
		/**
		 * Display name for list; can not be empty. \
		 * Minimum string length: 1 \
		 * Maximum string length: 64
		 */
		name: string;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: AppBskyRichtextFacet.Main[];
		avatar?: At.Blob<`image/png` | `image/jpeg`>;
		labels?: Brand.Union<ComAtprotoLabelDefs.SelfLabels>;
		createdAt: string;
	}
}

export declare namespace AppBskyGraphListblock {
	interface Record {
		/** Reference (AT-URI) to the mod list record. */
		subject: At.Uri;
		createdAt: string;
	}
}

export declare namespace AppBskyGraphListitem {
	interface Record {
		/** The account which is included on the list. */
		subject: At.DID;
		/** Reference (AT-URI) to the list record (app.bsky.graph.list). */
		list: At.Uri;
		createdAt: string;
	}
}

/** Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteActor {
	interface Params {}
	interface Input {
		actor: string;
	}
	type Output = undefined;
}

/** Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteActorList {
	interface Params {}
	interface Input {
		list: At.Uri;
	}
	type Output = undefined;
}

/** Unmutes the specified account. Requires auth. */
export declare namespace AppBskyGraphUnmuteActor {
	interface Params {}
	interface Input {
		actor: string;
	}
	type Output = undefined;
}

/** Unmutes the specified list of accounts. Requires auth. */
export declare namespace AppBskyGraphUnmuteActorList {
	interface Params {}
	interface Input {
		list: At.Uri;
	}
	type Output = undefined;
}

/** Count the number of unread notifications for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationGetUnreadCount {
	interface Params {
		seenAt?: string;
	}
	type Input = undefined;
	interface Output {
		count: number;
	}
}

/** Enumerate notifications for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationListNotifications {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
		seenAt?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		notifications: Notification[];
		seenAt?: string;
	}
	interface Notification {
		[Brand.Type]?: 'app.bsky.notification.listNotifications#notification';
		uri: At.Uri;
		cid: At.CID;
		author: AppBskyActorDefs.ProfileView;
		/** Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'. */
		reason: 'like' | 'repost' | 'follow' | 'mention' | 'reply' | 'quote' | (string & {});
		reasonSubject?: At.Uri;
		record: unknown;
		isRead: boolean;
		indexedAt: string;
		labels?: ComAtprotoLabelDefs.Label[];
	}
}

/** Register to receive push notifications, via a specified service, for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationRegisterPush {
	interface Params {}
	interface Input {
		serviceDid: At.DID;
		token: string;
		platform: 'ios' | 'android' | 'web' | (string & {});
		appId: string;
	}
	type Output = undefined;
}

/** Notify server that the requesting account has seen notifications. Requires auth. */
export declare namespace AppBskyNotificationUpdateSeen {
	interface Params {}
	interface Input {
		seenAt: string;
	}
	type Output = undefined;
}

export declare namespace AppBskyRichtextFacet {
	/** Annotation of a sub-string within rich text. */
	interface Main {
		[Brand.Type]?: 'app.bsky.richtext.facet';
		index: ByteSlice;
		features: Brand.Union<Mention | Link | Tag>[];
	}
	/** Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID. */
	interface Mention {
		[Brand.Type]?: 'app.bsky.richtext.facet#mention';
		did: At.DID;
	}
	/** Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL. */
	interface Link {
		[Brand.Type]?: 'app.bsky.richtext.facet#link';
		uri: string;
	}
	/** Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags'). */
	interface Tag {
		[Brand.Type]?: 'app.bsky.richtext.facet#tag';
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		tag: string;
	}
	/** Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets. */
	interface ByteSlice {
		[Brand.Type]?: 'app.bsky.richtext.facet#byteSlice';
		/** Minimum: 0 */
		byteStart: number;
		/** Minimum: 0 */
		byteEnd: number;
	}
}

export declare namespace AppBskyUnspeccedDefs {
	interface SkeletonSearchPost {
		[Brand.Type]?: 'app.bsky.unspecced.defs#skeletonSearchPost';
		uri: At.Uri;
	}
	interface SkeletonSearchActor {
		[Brand.Type]?: 'app.bsky.unspecced.defs#skeletonSearchActor';
		did: At.DID;
	}
}

/** An unspecced view of globally popular feed generators. */
export declare namespace AppBskyUnspeccedGetPopularFeedGenerators {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
		query?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		feeds: AppBskyFeedDefs.GeneratorView[];
	}
}

/** Get a list of suggestions (feeds and users) tagged with categories */
export declare namespace AppBskyUnspeccedGetTaggedSuggestions {
	interface Params {}
	type Input = undefined;
	interface Output {
		suggestions: Suggestion[];
	}
	interface Suggestion {
		[Brand.Type]?: 'app.bsky.unspecced.getTaggedSuggestions#suggestion';
		tag: string;
		subjectType: 'actor' | 'feed' | (string & {});
		subject: string;
	}
}

/** Backend Actors (profile) search, returns only skeleton. */
export declare namespace AppBskyUnspeccedSearchActorsSkeleton {
	interface Params {
		/** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax. */
		q: string;
		/** If true, acts as fast/simple 'typeahead' query. */
		typeahead?: boolean;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 25
		 */
		limit?: number;
		/** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		/** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
		hitsTotal?: number;
		actors: AppBskyUnspeccedDefs.SkeletonSearchActor[];
	}
	interface Errors {
		BadQueryString: {};
	}
}

/** Backend Posts search, returns only skeleton */
export declare namespace AppBskyUnspeccedSearchPostsSkeleton {
	interface Params {
		/** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
		q: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 25
		 */
		limit?: number;
		/** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		/** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
		hitsTotal?: number;
		posts: AppBskyUnspeccedDefs.SkeletonSearchPost[];
	}
	interface Errors {
		BadQueryString: {};
	}
}

/** Administrative action to create a new, re-usable communication (email for now) template. */
export declare namespace ComAtprotoAdminCreateCommunicationTemplate {
	interface Params {}
	interface Input {
		/** Name of the template. */
		name: string;
		/** Content of the template, markdown supported, can contain variable placeholders. */
		contentMarkdown: string;
		/** Subject of the message, used in emails. */
		subject: string;
		/** DID of the user who is creating the template. */
		createdBy?: At.DID;
	}
	type Output = ComAtprotoAdminDefs.CommunicationTemplateView;
}

export declare namespace ComAtprotoAdminDefs {
	interface StatusAttr {
		[Brand.Type]?: 'com.atproto.admin.defs#statusAttr';
		applied: boolean;
		ref?: string;
	}
	interface ModEventView {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventView';
		id: number;
		event: Brand.Union<
			| ModEventTakedown
			| ModEventReverseTakedown
			| ModEventComment
			| ModEventReport
			| ModEventLabel
			| ModEventAcknowledge
			| ModEventEscalate
			| ModEventMute
			| ModEventEmail
			| ModEventResolveAppeal
		>;
		subject: Brand.Union<RepoRef | ComAtprotoRepoStrongRef.Main>;
		subjectBlobCids: string[];
		createdBy: At.DID;
		createdAt: string;
		creatorHandle?: string;
		subjectHandle?: string;
	}
	interface ModEventViewDetail {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventViewDetail';
		id: number;
		event: Brand.Union<
			| ModEventTakedown
			| ModEventReverseTakedown
			| ModEventComment
			| ModEventReport
			| ModEventLabel
			| ModEventAcknowledge
			| ModEventEscalate
			| ModEventMute
			| ModEventEmail
			| ModEventResolveAppeal
		>;
		subject: Brand.Union<RepoView | RepoViewNotFound | RecordView | RecordViewNotFound>;
		subjectBlobs: BlobView[];
		createdBy: At.DID;
		createdAt: string;
	}
	interface ReportView {
		[Brand.Type]?: 'com.atproto.admin.defs#reportView';
		id: number;
		reasonType: ComAtprotoModerationDefs.ReasonType;
		comment?: string;
		subjectRepoHandle?: string;
		subject: Brand.Union<RepoRef | ComAtprotoRepoStrongRef.Main>;
		reportedBy: At.DID;
		createdAt: string;
		resolvedByActionIds: number[];
	}
	interface SubjectStatusView {
		[Brand.Type]?: 'com.atproto.admin.defs#subjectStatusView';
		id: number;
		subject: Brand.Union<RepoRef | ComAtprotoRepoStrongRef.Main>;
		subjectBlobCids?: At.CID[];
		subjectRepoHandle?: string;
		/** Timestamp referencing when the last update was made to the moderation status of the subject */
		updatedAt: string;
		/** Timestamp referencing the first moderation status impacting event was emitted on the subject */
		createdAt: string;
		reviewState: SubjectReviewState;
		/** Sticky comment on the subject. */
		comment?: string;
		muteUntil?: string;
		lastReviewedBy?: At.DID;
		lastReviewedAt?: string;
		lastReportedAt?: string;
		/** Timestamp referencing when the author of the subject appealed a moderation action */
		lastAppealedAt?: string;
		takendown?: boolean;
		/** True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators. */
		appealed?: boolean;
		suspendUntil?: string;
		tags?: string[];
	}
	interface ReportViewDetail {
		[Brand.Type]?: 'com.atproto.admin.defs#reportViewDetail';
		id: number;
		reasonType: ComAtprotoModerationDefs.ReasonType;
		comment?: string;
		subject: Brand.Union<RepoView | RepoViewNotFound | RecordView | RecordViewNotFound>;
		subjectStatus?: ComAtprotoAdminDefs.SubjectStatusView;
		reportedBy: At.DID;
		createdAt: string;
		resolvedByActions: ComAtprotoAdminDefs.ModEventView[];
	}
	interface RepoView {
		[Brand.Type]?: 'com.atproto.admin.defs#repoView';
		did: At.DID;
		handle: At.Handle;
		email?: string;
		relatedRecords: unknown[];
		indexedAt: string;
		moderation: Moderation;
		invitedBy?: ComAtprotoServerDefs.InviteCode;
		invitesDisabled?: boolean;
		inviteNote?: string;
	}
	interface RepoViewDetail {
		[Brand.Type]?: 'com.atproto.admin.defs#repoViewDetail';
		did: At.DID;
		handle: At.Handle;
		email?: string;
		relatedRecords: unknown[];
		indexedAt: string;
		moderation: ModerationDetail;
		labels?: ComAtprotoLabelDefs.Label[];
		invitedBy?: ComAtprotoServerDefs.InviteCode;
		invites?: ComAtprotoServerDefs.InviteCode[];
		invitesDisabled?: boolean;
		inviteNote?: string;
		emailConfirmedAt?: string;
	}
	interface AccountView {
		[Brand.Type]?: 'com.atproto.admin.defs#accountView';
		did: At.DID;
		handle: At.Handle;
		email?: string;
		relatedRecords?: unknown[];
		indexedAt: string;
		invitedBy?: ComAtprotoServerDefs.InviteCode;
		invites?: ComAtprotoServerDefs.InviteCode[];
		invitesDisabled?: boolean;
		emailConfirmedAt?: string;
		inviteNote?: string;
	}
	interface RepoViewNotFound {
		[Brand.Type]?: 'com.atproto.admin.defs#repoViewNotFound';
		did: At.DID;
	}
	interface RepoRef {
		[Brand.Type]?: 'com.atproto.admin.defs#repoRef';
		did: At.DID;
	}
	interface RepoBlobRef {
		[Brand.Type]?: 'com.atproto.admin.defs#repoBlobRef';
		did: At.DID;
		cid: At.CID;
		recordUri?: At.Uri;
	}
	interface RecordView {
		[Brand.Type]?: 'com.atproto.admin.defs#recordView';
		uri: At.Uri;
		cid: At.CID;
		value: unknown;
		blobCids: At.CID[];
		indexedAt: string;
		moderation: Moderation;
		repo: RepoView;
	}
	interface RecordViewDetail {
		[Brand.Type]?: 'com.atproto.admin.defs#recordViewDetail';
		uri: At.Uri;
		cid: At.CID;
		value: unknown;
		blobs: BlobView[];
		labels?: ComAtprotoLabelDefs.Label[];
		indexedAt: string;
		moderation: ModerationDetail;
		repo: RepoView;
	}
	interface RecordViewNotFound {
		[Brand.Type]?: 'com.atproto.admin.defs#recordViewNotFound';
		uri: At.Uri;
	}
	interface Moderation {
		[Brand.Type]?: 'com.atproto.admin.defs#moderation';
		subjectStatus?: SubjectStatusView;
	}
	interface ModerationDetail {
		[Brand.Type]?: 'com.atproto.admin.defs#moderationDetail';
		subjectStatus?: SubjectStatusView;
	}
	interface BlobView {
		[Brand.Type]?: 'com.atproto.admin.defs#blobView';
		cid: At.CID;
		mimeType: string;
		size: number;
		createdAt: string;
		details?: Brand.Union<ImageDetails | VideoDetails>;
		moderation?: Moderation;
	}
	interface ImageDetails {
		[Brand.Type]?: 'com.atproto.admin.defs#imageDetails';
		width: number;
		height: number;
	}
	interface VideoDetails {
		[Brand.Type]?: 'com.atproto.admin.defs#videoDetails';
		width: number;
		height: number;
		length: number;
	}
	type SubjectReviewState = '#reviewOpen' | '#reviewEscalated' | '#reviewClosed' | (string & {});
	type ReviewOpen = 'com.atproto.admin.defs#reviewOpen';
	type ReviewEscalated = 'com.atproto.admin.defs#reviewEscalated';
	type ReviewClosed = 'com.atproto.admin.defs#reviewClosed';
	/** Take down a subject permanently or temporarily */
	interface ModEventTakedown {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventTakedown';
		comment?: string;
		/** Indicates how long the takedown should be in effect before automatically expiring. */
		durationInHours?: number;
	}
	/** Revert take down action on a subject */
	interface ModEventReverseTakedown {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventReverseTakedown';
		/** Describe reasoning behind the reversal. */
		comment?: string;
	}
	/** Resolve appeal on a subject */
	interface ModEventResolveAppeal {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventResolveAppeal';
		/** Describe resolution. */
		comment?: string;
	}
	/** Add a comment to a subject */
	interface ModEventComment {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventComment';
		comment: string;
		/** Make the comment persistent on the subject */
		sticky?: boolean;
	}
	/** Report a subject */
	interface ModEventReport {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventReport';
		comment?: string;
		reportType: ComAtprotoModerationDefs.ReasonType;
	}
	/** Apply/Negate labels on a subject */
	interface ModEventLabel {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventLabel';
		comment?: string;
		createLabelVals: string[];
		negateLabelVals: string[];
	}
	interface ModEventAcknowledge {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventAcknowledge';
		comment?: string;
	}
	interface ModEventEscalate {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventEscalate';
		comment?: string;
	}
	/** Mute incoming reports on a subject */
	interface ModEventMute {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventMute';
		comment?: string;
		/** Indicates how long the subject should remain muted. */
		durationInHours: number;
	}
	/** Unmute action on a subject */
	interface ModEventUnmute {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventUnmute';
		/** Describe reasoning behind the reversal. */
		comment?: string;
	}
	/** Keep a log of outgoing email to a user */
	interface ModEventEmail {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventEmail';
		/** The subject line of the email sent to the user. */
		subjectLine: string;
		/** Additional comment about the outgoing comm. */
		comment?: string;
	}
	/** Add/Remove a tag on a subject */
	interface ModEventTag {
		[Brand.Type]?: 'com.atproto.admin.defs#modEventTag';
		/** Tags to be added to the subject. If already exists, won't be duplicated. */
		add: string[];
		/** Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated. */
		remove: string[];
		/** Additional comment about added/removed tags. */
		comment?: string;
	}
	interface CommunicationTemplateView {
		[Brand.Type]?: 'com.atproto.admin.defs#communicationTemplateView';
		id: string;
		/** Name of the template. */
		name: string;
		/** Content of the template, can contain markdown and variable placeholders. */
		subject?: string;
		/** Subject of the message, used in emails. */
		contentMarkdown: string;
		disabled: boolean;
		/** DID of the user who last updated the template. */
		lastUpdatedBy: At.DID;
		createdAt: string;
		updatedAt: string;
	}
}

/** Delete a user account as an administrator. */
export declare namespace ComAtprotoAdminDeleteAccount {
	interface Params {}
	interface Input {
		did: At.DID;
	}
	type Output = undefined;
}

/** Delete a communication template. */
export declare namespace ComAtprotoAdminDeleteCommunicationTemplate {
	interface Params {}
	interface Input {
		id: string;
	}
	type Output = undefined;
}

/** Disable an account from receiving new invite codes, but does not invalidate existing codes. */
export declare namespace ComAtprotoAdminDisableAccountInvites {
	interface Params {}
	interface Input {
		account: At.DID;
		/** Optional reason for disabled invites. */
		note?: string;
	}
	type Output = undefined;
}

/** Disable some set of codes and/or all codes associated with a set of users. */
export declare namespace ComAtprotoAdminDisableInviteCodes {
	interface Params {}
	interface Input {
		codes?: string[];
		accounts?: string[];
	}
	type Output = undefined;
}

/** Take a moderation action on an actor. */
export declare namespace ComAtprotoAdminEmitModerationEvent {
	interface Params {}
	interface Input {
		event: Brand.Union<
			| ComAtprotoAdminDefs.ModEventTakedown
			| ComAtprotoAdminDefs.ModEventAcknowledge
			| ComAtprotoAdminDefs.ModEventEscalate
			| ComAtprotoAdminDefs.ModEventComment
			| ComAtprotoAdminDefs.ModEventLabel
			| ComAtprotoAdminDefs.ModEventReport
			| ComAtprotoAdminDefs.ModEventMute
			| ComAtprotoAdminDefs.ModEventReverseTakedown
			| ComAtprotoAdminDefs.ModEventUnmute
			| ComAtprotoAdminDefs.ModEventEmail
			| ComAtprotoAdminDefs.ModEventTag
		>;
		subject: Brand.Union<ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main>;
		subjectBlobCids?: At.CID[];
		createdBy: At.DID;
	}
	type Output = ComAtprotoAdminDefs.ModEventView;
	interface Errors {
		SubjectHasAction: {};
	}
}

/** Re-enable an account's ability to receive invite codes. */
export declare namespace ComAtprotoAdminEnableAccountInvites {
	interface Params {}
	interface Input {
		account: At.DID;
		/** Optional reason for enabled invites. */
		note?: string;
	}
	type Output = undefined;
}

/** Get details about an account. */
export declare namespace ComAtprotoAdminGetAccountInfo {
	interface Params {
		did: At.DID;
	}
	type Input = undefined;
	type Output = ComAtprotoAdminDefs.AccountView;
}

/** Get details about some accounts. */
export declare namespace ComAtprotoAdminGetAccountInfos {
	interface Params {
		dids: At.DID[];
	}
	type Input = undefined;
	interface Output {
		infos: ComAtprotoAdminDefs.AccountView[];
	}
}

/** Get an admin view of invite codes. */
export declare namespace ComAtprotoAdminGetInviteCodes {
	interface Params {
		/** @default "recent" */
		sort?: 'recent' | 'usage' | (string & {});
		/**
		 * Minimum: 1 \
		 * Maximum: 500
		 * @default 100
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		codes: ComAtprotoServerDefs.InviteCode[];
	}
}

/** Get details about a moderation event. */
export declare namespace ComAtprotoAdminGetModerationEvent {
	interface Params {
		id: number;
	}
	type Input = undefined;
	type Output = ComAtprotoAdminDefs.ModEventViewDetail;
}

/** Get details about a record. */
export declare namespace ComAtprotoAdminGetRecord {
	interface Params {
		uri: At.Uri;
		cid?: At.CID;
	}
	type Input = undefined;
	type Output = ComAtprotoAdminDefs.RecordViewDetail;
	interface Errors {
		RecordNotFound: {};
	}
}

/** Get details about a repository. */
export declare namespace ComAtprotoAdminGetRepo {
	interface Params {
		did: At.DID;
	}
	type Input = undefined;
	type Output = ComAtprotoAdminDefs.RepoViewDetail;
	interface Errors {
		RepoNotFound: {};
	}
}

/** Get the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminGetSubjectStatus {
	interface Params {
		did?: At.DID;
		uri?: At.Uri;
		blob?: At.CID;
	}
	type Input = undefined;
	interface Output {
		subject: Brand.Union<
			ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main | ComAtprotoAdminDefs.RepoBlobRef
		>;
		takedown?: ComAtprotoAdminDefs.StatusAttr;
	}
}

/** Get list of all communication templates. */
export declare namespace ComAtprotoAdminListCommunicationTemplates {
	interface Params {}
	type Input = undefined;
	interface Output {
		communicationTemplates: ComAtprotoAdminDefs.CommunicationTemplateView[];
	}
}

/** List moderation events related to a subject. */
export declare namespace ComAtprotoAdminQueryModerationEvents {
	interface Params {
		/** The types of events (fully qualified string in the format of com.atproto.admin#modEvent<name>) to filter by. If not specified, all events are returned. */
		types?: string[];
		createdBy?: At.DID;
		/**
		 * Sort direction for the events. Defaults to descending order of created at timestamp.
		 * @default "desc"
		 */
		sortDirection?: string;
		/** Retrieve events created after a given timestamp */
		createdAfter?: string;
		/** Retrieve events created before a given timestamp */
		createdBefore?: string;
		subject?: string;
		/**
		 * If true, events on all record types (posts, lists, profile etc.) owned by the did are returned
		 * @default false
		 */
		includeAllUserRecords?: boolean;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		/** If true, only events with comments are returned */
		hasComment?: boolean;
		/** If specified, only events with comments containing the keyword are returned */
		comment?: string;
		/** If specified, only events where all of these labels were added are returned */
		addedLabels?: string[];
		/** If specified, only events where all of these labels were removed are returned */
		removedLabels?: string[];
		/** If specified, only events where all of these tags were added are returned */
		addedTags?: string[];
		/** If specified, only events where all of these tags were removed are returned */
		removedTags?: string[];
		reportTypes?: string[];
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		events: ComAtprotoAdminDefs.ModEventView[];
	}
}

/** View moderation statuses of subjects (record or repo). */
export declare namespace ComAtprotoAdminQueryModerationStatuses {
	interface Params {
		subject?: string;
		/** Search subjects by keyword from comments */
		comment?: string;
		/** Search subjects reported after a given timestamp */
		reportedAfter?: string;
		/** Search subjects reported before a given timestamp */
		reportedBefore?: string;
		/** Search subjects reviewed after a given timestamp */
		reviewedAfter?: string;
		/** Search subjects reviewed before a given timestamp */
		reviewedBefore?: string;
		/** By default, we don't include muted subjects in the results. Set this to true to include them. */
		includeMuted?: boolean;
		/** Specify when fetching subjects in a certain state */
		reviewState?: string;
		ignoreSubjects?: string[];
		/** Get all subject statuses that were reviewed by a specific moderator */
		lastReviewedBy?: At.DID;
		/** @default "lastReportedAt" */
		sortField?: string;
		/** @default "desc" */
		sortDirection?: string;
		/** Get subjects that were taken down */
		takendown?: boolean;
		/** Get subjects in unresolved appealed status */
		appealed?: boolean;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		tags?: string[];
		excludeTags?: string[];
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		subjectStatuses: ComAtprotoAdminDefs.SubjectStatusView[];
	}
}

/** Find repositories based on a search term. */
export declare namespace ComAtprotoAdminSearchRepos {
	interface Params {
		/**
		 * DEPRECATED: use 'q' instead
		 * @deprecated
		 */
		term?: string;
		q?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		repos: ComAtprotoAdminDefs.RepoView[];
	}
}

/** Send email to a user's account email address. */
export declare namespace ComAtprotoAdminSendEmail {
	interface Params {}
	interface Input {
		recipientDid: At.DID;
		content: string;
		subject?: string;
		senderDid: At.DID;
		/** Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers */
		comment?: string;
	}
	interface Output {
		sent: boolean;
	}
}

/** Administrative action to update an account's email. */
export declare namespace ComAtprotoAdminUpdateAccountEmail {
	interface Params {}
	interface Input {
		/** The handle or DID of the repo. */
		account: string;
		email: string;
	}
	type Output = undefined;
}

/** Administrative action to update an account's handle. */
export declare namespace ComAtprotoAdminUpdateAccountHandle {
	interface Params {}
	interface Input {
		did: At.DID;
		handle: At.Handle;
	}
	type Output = undefined;
}

/** Update the password for a user account as an administrator. */
export declare namespace ComAtprotoAdminUpdateAccountPassword {
	interface Params {}
	interface Input {
		did: At.DID;
		password: string;
	}
	type Output = undefined;
}

/** Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only. */
export declare namespace ComAtprotoAdminUpdateCommunicationTemplate {
	interface Params {}
	interface Input {
		/** ID of the template to be updated. */
		id: string;
		/** Name of the template. */
		name?: string;
		/** Content of the template, markdown supported, can contain variable placeholders. */
		contentMarkdown?: string;
		/** Subject of the message, used in emails. */
		subject?: string;
		/** DID of the user who is updating the template. */
		updatedBy?: At.DID;
		disabled?: boolean;
	}
	type Output = ComAtprotoAdminDefs.CommunicationTemplateView;
}

/** Update the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminUpdateSubjectStatus {
	interface Params {}
	interface Input {
		subject: Brand.Union<
			ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main | ComAtprotoAdminDefs.RepoBlobRef
		>;
		takedown?: ComAtprotoAdminDefs.StatusAttr;
	}
	interface Output {
		subject: Brand.Union<
			ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main | ComAtprotoAdminDefs.RepoBlobRef
		>;
		takedown?: ComAtprotoAdminDefs.StatusAttr;
	}
}

/** Describe the credentials that should be included in the DID doc of an account that is migrating to this service. */
export declare namespace ComAtprotoIdentityGetRecommendedDidCredentials {
	interface Params {}
	type Input = undefined;
	interface Output {
		/** Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs. */
		rotationKeys?: string[];
		alsoKnownAs?: string[];
		verificationMethods?: unknown;
		services?: unknown;
	}
}

/** Request an email with a code to in order to request a signed PLC operation. Requires Auth. */
export declare namespace ComAtprotoIdentityRequestPlcOperationSignature {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Resolves a handle (domain name) to a DID. */
export declare namespace ComAtprotoIdentityResolveHandle {
	interface Params {
		/** The handle to resolve. */
		handle: At.Handle;
	}
	type Input = undefined;
	interface Output {
		did: At.DID;
	}
}

/** Signs a PLC operation to update some value(s) in the requesting DID's document. */
export declare namespace ComAtprotoIdentitySignPlcOperation {
	interface Params {}
	interface Input {
		/** A token received through com.atproto.identity.requestPlcOperationSignature */
		token?: string;
		rotationKeys?: string[];
		alsoKnownAs?: string[];
		verificationMethods?: unknown;
		services?: unknown;
	}
	interface Output {
		/** A signed DID PLC operation. */
		operation: unknown;
	}
}

/** Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry */
export declare namespace ComAtprotoIdentitySubmitPlcOperation {
	interface Params {}
	interface Input {
		operation: unknown;
	}
	type Output = undefined;
}

/** Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth. */
export declare namespace ComAtprotoIdentityUpdateHandle {
	interface Params {}
	interface Input {
		/** The new handle. */
		handle: At.Handle;
	}
	type Output = undefined;
}

export declare namespace ComAtprotoLabelDefs {
	/** Metadata tag on an atproto resource (eg, repo or record). */
	interface Label {
		[Brand.Type]?: 'com.atproto.label.defs#label';
		/** DID of the actor who created this label. */
		src: At.DID;
		/** AT URI of the record, repository (account), or other resource that this label applies to. */
		uri: string;
		/** Optionally, CID specifying the specific version of 'uri' resource this label applies to. */
		cid?: At.CID;
		/**
		 * The short string name of the value or type of this label. \
		 * Maximum string length: 128
		 */
		val: string;
		/** If true, this is a negation label, overwriting a previous label. */
		neg?: boolean;
		/** Timestamp when this label was created. */
		cts: string;
	}
	/** Metadata tags on an atproto record, published by the author within the record. */
	interface SelfLabels {
		[Brand.Type]?: 'com.atproto.label.defs#selfLabels';
		/** Maximum array length: 10 */
		values: SelfLabel[];
	}
	/** Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel. */
	interface SelfLabel {
		[Brand.Type]?: 'com.atproto.label.defs#selfLabel';
		/**
		 * The short string name of the value or type of this label. \
		 * Maximum string length: 128
		 */
		val: string;
	}
}

/** Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth. */
export declare namespace ComAtprotoLabelQueryLabels {
	interface Params {
		/** List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI. */
		uriPatterns: string[];
		/** Optional list of label sources (DIDs) to filter on. */
		sources?: At.DID[];
		/**
		 * Minimum: 1 \
		 * Maximum: 250
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		labels: ComAtprotoLabelDefs.Label[];
	}
}

export declare namespace ComAtprotoLabelSubscribeLabels {
	interface Labels {
		[Brand.Type]?: 'com.atproto.label.subscribeLabels#labels';
		seq: number;
		labels: ComAtprotoLabelDefs.Label[];
	}
	interface Info {
		[Brand.Type]?: 'com.atproto.label.subscribeLabels#info';
		name: 'OutdatedCursor' | (string & {});
		message?: string;
	}
}

/** Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth. */
export declare namespace ComAtprotoModerationCreateReport {
	interface Params {}
	interface Input {
		/** Indicates the broad category of violation the report is for. */
		reasonType: ComAtprotoModerationDefs.ReasonType;
		/** Additional context about the content and violation. */
		reason?: string;
		subject: Brand.Union<ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main>;
	}
	interface Output {
		id: number;
		reasonType: ComAtprotoModerationDefs.ReasonType;
		/**
		 * Maximum string length: 20000 \
		 * Maximum grapheme length: 2000
		 */
		reason?: string;
		subject: Brand.Union<ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main>;
		reportedBy: At.DID;
		createdAt: string;
	}
}

export declare namespace ComAtprotoModerationDefs {
	type ReasonType =
		| 'com.atproto.moderation.defs#reasonSpam'
		| 'com.atproto.moderation.defs#reasonViolation'
		| 'com.atproto.moderation.defs#reasonMisleading'
		| 'com.atproto.moderation.defs#reasonSexual'
		| 'com.atproto.moderation.defs#reasonRude'
		| 'com.atproto.moderation.defs#reasonOther'
		| 'com.atproto.moderation.defs#reasonAppeal'
		| (string & {});
	type ReasonSpam = 'com.atproto.moderation.defs#reasonSpam';
	type ReasonViolation = 'com.atproto.moderation.defs#reasonViolation';
	type ReasonMisleading = 'com.atproto.moderation.defs#reasonMisleading';
	type ReasonSexual = 'com.atproto.moderation.defs#reasonSexual';
	type ReasonRude = 'com.atproto.moderation.defs#reasonRude';
	type ReasonOther = 'com.atproto.moderation.defs#reasonOther';
	type ReasonAppeal = 'com.atproto.moderation.defs#reasonAppeal';
}

/** Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoApplyWrites {
	interface Params {}
	interface Input {
		/** The handle or DID of the repo (aka, current account). */
		repo: string;
		/**
		 * Can be set to 'false' to skip Lexicon schema validation of record data, for all operations.
		 * @default true
		 */
		validate?: boolean;
		writes: Brand.Union<Create | Update | Delete>[];
		/** If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations. */
		swapCommit?: At.CID;
	}
	type Output = undefined;
	interface Errors {
		InvalidSwap: {};
	}
	/** Operation which creates a new record. */
	interface Create {
		[Brand.Type]?: 'com.atproto.repo.applyWrites#create';
		collection: string;
		/** Maximum string length: 15 */
		rkey?: string;
		value: unknown;
	}
	/** Operation which updates an existing record. */
	interface Update {
		[Brand.Type]?: 'com.atproto.repo.applyWrites#update';
		collection: string;
		rkey: string;
		value: unknown;
	}
	/** Operation which deletes an existing record. */
	interface Delete {
		[Brand.Type]?: 'com.atproto.repo.applyWrites#delete';
		collection: string;
		rkey: string;
	}
}

/** Create a single new repository record. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoCreateRecord {
	interface Params {}
	interface Input {
		/** The handle or DID of the repo (aka, current account). */
		repo: string;
		/** The NSID of the record collection. */
		collection: string;
		/**
		 * The Record Key. \
		 * Maximum string length: 15
		 */
		rkey?: string;
		/**
		 * Can be set to 'false' to skip Lexicon schema validation of record data.
		 * @default true
		 */
		validate?: boolean;
		/** The record itself. Must contain a $type field. */
		record: unknown;
		/** Compare and swap with the previous commit by CID. */
		swapCommit?: At.CID;
	}
	interface Output {
		uri: At.Uri;
		cid: At.CID;
	}
	interface Errors {
		InvalidSwap: {};
	}
}

/** Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoDeleteRecord {
	interface Params {}
	interface Input {
		/** The handle or DID of the repo (aka, current account). */
		repo: string;
		/** The NSID of the record collection. */
		collection: string;
		/** The Record Key. */
		rkey: string;
		/** Compare and swap with the previous record by CID. */
		swapRecord?: At.CID;
		/** Compare and swap with the previous commit by CID. */
		swapCommit?: At.CID;
	}
	type Output = undefined;
	interface Errors {
		InvalidSwap: {};
	}
}

/** Get information about an account and repository, including the list of collections. Does not require auth. */
export declare namespace ComAtprotoRepoDescribeRepo {
	interface Params {
		/** The handle or DID of the repo. */
		repo: string;
	}
	type Input = undefined;
	interface Output {
		handle: At.Handle;
		did: At.DID;
		/** The complete DID document for this account. */
		didDoc: unknown;
		/** List of all the collections (NSIDs) for which this repo contains at least one record. */
		collections: string[];
		/** Indicates if handle is currently valid (resolves bi-directionally) */
		handleIsCorrect: boolean;
	}
}

/** Get a single record from a repository. Does not require auth. */
export declare namespace ComAtprotoRepoGetRecord {
	interface Params {
		/** The handle or DID of the repo. */
		repo: string;
		/** The NSID of the record collection. */
		collection: string;
		/** The Record Key. */
		rkey: string;
		/** The CID of the version of the record. If not specified, then return the most recent version. */
		cid?: At.CID;
	}
	type Input = undefined;
	interface Output {
		uri: At.Uri;
		cid?: At.CID;
		value: unknown;
	}
}

/** Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set. */
export declare namespace ComAtprotoRepoImportRepo {
	interface Params {}
	type Input = Blob | ArrayBuffer;
	type Output = undefined;
}

/** Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow. */
export declare namespace ComAtprotoRepoListMissingBlobs {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 1000
		 * @default 500
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		blobs: RecordBlob[];
	}
	interface RecordBlob {
		[Brand.Type]?: 'com.atproto.repo.listMissingBlobs#recordBlob';
		cid: At.CID;
		recordUri: At.Uri;
	}
}

/** List a range of records in a repository, matching a specific collection. Does not require auth. */
export declare namespace ComAtprotoRepoListRecords {
	interface Params {
		/** The handle or DID of the repo. */
		repo: string;
		/** The NSID of the record type. */
		collection: string;
		/**
		 * The number of records to return. \
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		cursor?: string;
		/**
		 * DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)
		 * @deprecated
		 */
		rkeyStart?: string;
		/**
		 * DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)
		 * @deprecated
		 */
		rkeyEnd?: string;
		/** Flag to reverse the order of the returned records. */
		reverse?: boolean;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		records: Record[];
	}
	interface Record {
		[Brand.Type]?: 'com.atproto.repo.listRecords#record';
		uri: At.Uri;
		cid: At.CID;
		value: unknown;
	}
}

/** Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoPutRecord {
	interface Params {}
	interface Input {
		/** The handle or DID of the repo (aka, current account). */
		repo: string;
		/** The NSID of the record collection. */
		collection: string;
		/**
		 * The Record Key. \
		 * Maximum string length: 15
		 */
		rkey: string;
		/**
		 * Can be set to 'false' to skip Lexicon schema validation of record data.
		 * @default true
		 */
		validate?: boolean;
		/** The record to write. */
		record: unknown;
		/** Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation */
		swapRecord?: At.CID;
		/** Compare and swap with the previous commit by CID. */
		swapCommit?: At.CID;
	}
	interface Output {
		uri: At.Uri;
		cid: At.CID;
	}
	interface Errors {
		InvalidSwap: {};
	}
}

export declare namespace ComAtprotoRepoStrongRef {
	interface Main {
		[Brand.Type]?: 'com.atproto.repo.strongRef';
		uri: At.Uri;
		cid: At.CID;
	}
}

/** Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoUploadBlob {
	interface Params {}
	type Input = Blob | ArrayBuffer;
	interface Output {
		blob: At.Blob;
	}
}

/** Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup. */
export declare namespace ComAtprotoServerActivateAccount {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself. */
export declare namespace ComAtprotoServerCheckAccountStatus {
	interface Params {}
	type Input = undefined;
	interface Output {
		activated: boolean;
		validDid: boolean;
		repoCommit: At.CID;
		repoRev: string;
		repoBlocks: number;
		indexedRecords: number;
		privateStateValues: number;
		expectedBlobs: number;
		importedBlobs: number;
	}
}

/** Confirm an email using a token from com.atproto.server.requestEmailConfirmation. */
export declare namespace ComAtprotoServerConfirmEmail {
	interface Params {}
	interface Input {
		email: string;
		token: string;
	}
	type Output = undefined;
	interface Errors {
		AccountNotFound: {};
		ExpiredToken: {};
		InvalidToken: {};
		InvalidEmail: {};
	}
}

/** Create an account. Implemented by PDS. */
export declare namespace ComAtprotoServerCreateAccount {
	interface Params {}
	interface Input {
		email?: string;
		/** Requested handle for the account. */
		handle: At.Handle;
		/** Pre-existing atproto DID, being imported to a new account. */
		did?: At.DID;
		inviteCode?: string;
		verificationCode?: string;
		verificationPhone?: string;
		/** Initial account password. May need to meet instance-specific password strength requirements. */
		password?: string;
		/** DID PLC rotation key (aka, recovery key) to be included in PLC creation operation. */
		recoveryKey?: string;
		/** A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented. */
		plcOp?: unknown;
	}
	/** Account login session returned on successful account creation. */
	interface Output {
		accessJwt: string;
		refreshJwt: string;
		handle: At.Handle;
		/** The DID of the new account. */
		did: At.DID;
		/** Complete DID document. */
		didDoc?: unknown;
	}
	interface Errors {
		InvalidHandle: {};
		InvalidPassword: {};
		InvalidInviteCode: {};
		HandleNotAvailable: {};
		UnsupportedDomain: {};
		UnresolvableDid: {};
		IncompatibleDidDoc: {};
	}
}

/** Create an App Password. */
export declare namespace ComAtprotoServerCreateAppPassword {
	interface Params {}
	interface Input {
		/** A short name for the App Password, to help distinguish them. */
		name: string;
	}
	type Output = AppPassword;
	interface Errors {
		AccountTakedown: {};
	}
	interface AppPassword {
		[Brand.Type]?: 'com.atproto.server.createAppPassword#appPassword';
		name: string;
		password: string;
		createdAt: string;
	}
}

/** Create an invite code. */
export declare namespace ComAtprotoServerCreateInviteCode {
	interface Params {}
	interface Input {
		useCount: number;
		forAccount?: At.DID;
	}
	interface Output {
		code: string;
	}
}

/** Create invite codes. */
export declare namespace ComAtprotoServerCreateInviteCodes {
	interface Params {}
	interface Input {
		/** @default 1 */
		codeCount: number;
		useCount: number;
		forAccounts?: At.DID[];
	}
	interface Output {
		codes: AccountCodes[];
	}
	interface AccountCodes {
		[Brand.Type]?: 'com.atproto.server.createInviteCodes#accountCodes';
		account: string;
		codes: string[];
	}
}

/** Create an authentication session. */
export declare namespace ComAtprotoServerCreateSession {
	interface Params {}
	interface Input {
		/** Handle or other identifier supported by the server for the authenticating user. */
		identifier: string;
		password: string;
	}
	interface Output {
		accessJwt: string;
		refreshJwt: string;
		handle: At.Handle;
		did: At.DID;
		didDoc?: unknown;
		email?: string;
		emailConfirmed?: boolean;
	}
	interface Errors {
		AccountTakedown: {};
	}
}

/** Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host. */
export declare namespace ComAtprotoServerDeactivateAccount {
	interface Params {}
	interface Input {
		/** A recommendation to server as to how long they should hold onto the deactivated account before deleting. */
		deleteAfter?: string;
	}
	type Output = undefined;
}

export declare namespace ComAtprotoServerDefs {
	interface InviteCode {
		[Brand.Type]?: 'com.atproto.server.defs#inviteCode';
		code: string;
		available: number;
		disabled: boolean;
		forAccount: string;
		createdBy: string;
		createdAt: string;
		uses: InviteCodeUse[];
	}
	interface InviteCodeUse {
		[Brand.Type]?: 'com.atproto.server.defs#inviteCodeUse';
		usedBy: At.DID;
		usedAt: string;
	}
}

/** Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth. */
export declare namespace ComAtprotoServerDeleteAccount {
	interface Params {}
	interface Input {
		did: At.DID;
		password: string;
		token: string;
	}
	type Output = undefined;
	interface Errors {
		ExpiredToken: {};
		InvalidToken: {};
	}
}

/** Delete the current session. Requires auth. */
export declare namespace ComAtprotoServerDeleteSession {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Describes the server's account creation requirements and capabilities. Implemented by PDS. */
export declare namespace ComAtprotoServerDescribeServer {
	interface Params {}
	type Input = undefined;
	interface Output {
		/** If true, an invite code must be supplied to create an account on this instance. */
		inviteCodeRequired?: boolean;
		/** If true, a phone verification token must be supplied to create an account on this instance. */
		phoneVerificationRequired?: boolean;
		/** List of domain suffixes that can be used in account handles. */
		availableUserDomains: string[];
		/** URLs of service policy documents. */
		links?: Links;
		did: At.DID;
	}
	interface Links {
		[Brand.Type]?: 'com.atproto.server.describeServer#links';
		privacyPolicy?: string;
		termsOfService?: string;
	}
}

/** Get all invite codes for the current account. Requires auth. */
export declare namespace ComAtprotoServerGetAccountInviteCodes {
	interface Params {
		/** @default true */
		includeUsed?: boolean;
		/**
		 * Controls whether any new 'earned' but not 'created' invites should be created.
		 * @default true
		 */
		createAvailable?: boolean;
	}
	type Input = undefined;
	interface Output {
		codes: ComAtprotoServerDefs.InviteCode[];
	}
	interface Errors {
		DuplicateCreate: {};
	}
}

/** Get a signed token on behalf of the requesting DID for the requested service. */
export declare namespace ComAtprotoServerGetServiceAuth {
	interface Params {
		/** The DID of the service that the token will be used to authenticate with */
		aud: At.DID;
	}
	type Input = undefined;
	interface Output {
		token: string;
	}
}

/** Get information about the current auth session. Requires auth. */
export declare namespace ComAtprotoServerGetSession {
	interface Params {}
	type Input = undefined;
	interface Output {
		handle: At.Handle;
		did: At.DID;
		email?: string;
		emailConfirmed?: boolean;
		didDoc?: unknown;
	}
}

/** List all App Passwords. */
export declare namespace ComAtprotoServerListAppPasswords {
	interface Params {}
	type Input = undefined;
	interface Output {
		passwords: AppPassword[];
	}
	interface Errors {
		AccountTakedown: {};
	}
	interface AppPassword {
		[Brand.Type]?: 'com.atproto.server.listAppPasswords#appPassword';
		name: string;
		createdAt: string;
	}
}

/** Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt'). */
export declare namespace ComAtprotoServerRefreshSession {
	interface Params {}
	type Input = undefined;
	interface Output {
		accessJwt: string;
		refreshJwt: string;
		handle: At.Handle;
		did: At.DID;
		didDoc?: unknown;
	}
	interface Errors {
		AccountTakedown: {};
	}
}

/** Initiate a user account deletion via email. */
export declare namespace ComAtprotoServerRequestAccountDelete {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Request an email with a code to confirm ownership of email. */
export declare namespace ComAtprotoServerRequestEmailConfirmation {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Request a token in order to update email. */
export declare namespace ComAtprotoServerRequestEmailUpdate {
	interface Params {}
	type Input = undefined;
	interface Output {
		tokenRequired: boolean;
	}
}

/** Initiate a user account password reset via email. */
export declare namespace ComAtprotoServerRequestPasswordReset {
	interface Params {}
	interface Input {
		email: string;
	}
	type Output = undefined;
}

/** Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented. */
export declare namespace ComAtprotoServerReserveSigningKey {
	interface Params {}
	interface Input {
		/** The DID to reserve a key for. */
		did?: At.DID;
	}
	interface Output {
		/** The public key for the reserved signing key, in did:key serialization. */
		signingKey: string;
	}
}

/** Reset a user account password using a token. */
export declare namespace ComAtprotoServerResetPassword {
	interface Params {}
	interface Input {
		token: string;
		password: string;
	}
	type Output = undefined;
	interface Errors {
		ExpiredToken: {};
		InvalidToken: {};
	}
}

/** Revoke an App Password by name. */
export declare namespace ComAtprotoServerRevokeAppPassword {
	interface Params {}
	interface Input {
		name: string;
	}
	type Output = undefined;
}

/** Update an account's email. */
export declare namespace ComAtprotoServerUpdateEmail {
	interface Params {}
	interface Input {
		email: string;
		/** Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed. */
		token?: string;
	}
	type Output = undefined;
	interface Errors {
		ExpiredToken: {};
		InvalidToken: {};
		TokenRequired: {};
	}
}

/** Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlob {
	interface Params {
		/** The DID of the account. */
		did: At.DID;
		/** The CID of the blob to fetch */
		cid: At.CID;
	}
	type Input = undefined;
	type Output = Uint8Array;
}

/** Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlocks {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
		cids: At.CID[];
	}
	type Input = undefined;
	type Output = Uint8Array;
}

/**
 * DEPRECATED - please use com.atproto.sync.getRepo instead
 * @deprecated
 */
export declare namespace ComAtprotoSyncGetCheckout {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
	}
	type Input = undefined;
	type Output = Uint8Array;
}

/**
 * DEPRECATED - please use com.atproto.sync.getLatestCommit instead
 * @deprecated
 */
export declare namespace ComAtprotoSyncGetHead {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
	}
	type Input = undefined;
	interface Output {
		root: At.CID;
	}
	interface Errors {
		HeadNotFound: {};
	}
}

/** Get the current commit CID & revision of the specified repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetLatestCommit {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
	}
	type Input = undefined;
	interface Output {
		cid: At.CID;
		rev: string;
	}
	interface Errors {
		RepoNotFound: {};
	}
}

/** Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetRecord {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
		collection: string;
		/** Record Key */
		rkey: string;
		/** An optional past commit CID. */
		commit?: At.CID;
	}
	type Input = undefined;
	type Output = Uint8Array;
}

/** Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetRepo {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
		/** The revision ('rev') of the repo to create a diff from. */
		since?: string;
	}
	type Input = undefined;
	type Output = Uint8Array;
}

/** List blob CIDso for an account, since some repo revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncListBlobs {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
		/** Optional revision of the repo to list blobs since. */
		since?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 1000
		 * @default 500
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		cids: At.CID[];
	}
}

/** Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay. */
export declare namespace ComAtprotoSyncListRepos {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 1000
		 * @default 500
		 */
		limit?: number;
		cursor?: string;
	}
	type Input = undefined;
	interface Output {
		cursor?: string;
		repos: Repo[];
	}
	interface Repo {
		[Brand.Type]?: 'com.atproto.sync.listRepos#repo';
		did: At.DID;
		/** Current repo commit CID */
		head: At.CID;
		rev: string;
	}
}

/** Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay. */
export declare namespace ComAtprotoSyncNotifyOfUpdate {
	interface Params {}
	interface Input {
		/** Hostname of the current service (usually a PDS) that is notifying of update. */
		hostname: string;
	}
	type Output = undefined;
}

/** Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth. */
export declare namespace ComAtprotoSyncRequestCrawl {
	interface Params {}
	interface Input {
		/** Hostname of the current service (eg, PDS) that is requesting to be crawled. */
		hostname: string;
	}
	type Output = undefined;
}

export declare namespace ComAtprotoSyncSubscribeRepos {
	/** Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature. */
	interface Commit {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#commit';
		/** The stream sequence number of this message. */
		seq: number;
		/**
		 * DEPRECATED -- unused
		 * @deprecated
		 */
		rebase: boolean;
		/** Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data. */
		tooBig: boolean;
		/** The repo this event comes from. */
		repo: At.DID;
		/** Repo commit object CID. */
		commit: unknown;
		/**
		 * DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability.
		 * @deprecated
		 */
		prev?: unknown;
		/** The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event. */
		rev: string;
		/** The rev of the last emitted commit from this repo (if any). */
		since: string;
		/** CAR file containing relevant blocks, as a diff since the previous repo state. */
		blocks: unknown;
		/**
		 * Maximum array length: 200 \
		 * List of repo mutation operations in this commit (eg, records created, updated, or deleted).
		 */
		ops: RepoOp[];
		/** List of new blobs (by CID) referenced by records in this commit. */
		blobs: unknown[];
		/** Timestamp of when this message was originally broadcast. */
		time: string;
	}
	/** Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache. */
	interface Identity {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#identity';
		seq: number;
		did: At.DID;
		time: string;
	}
	/** Represents an update of the account's handle, or transition to/from invalid state. NOTE: Will be deprecated in favor of #identity. */
	interface Handle {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#handle';
		seq: number;
		did: At.DID;
		handle: At.Handle;
		time: string;
	}
	/** Represents an account moving from one PDS instance to another. NOTE: not implemented; account migration uses #identity instead */
	interface Migrate {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#migrate';
		seq: number;
		did: At.DID;
		migrateTo: string;
		time: string;
	}
	/** Indicates that an account has been deleted. NOTE: may be deprecated in favor of #identity or a future #account event */
	interface Tombstone {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#tombstone';
		seq: number;
		did: At.DID;
		time: string;
	}
	interface Info {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#info';
		name: 'OutdatedCursor' | (string & {});
		message?: string;
	}
	/** A repo operation, ie a mutation of a single record. */
	interface RepoOp {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#repoOp';
		action: 'create' | 'update' | 'delete' | (string & {});
		path: string;
		/** For creates and updates, the new record CID. For deletions, null. */
		cid: unknown;
	}
}

/** Check accounts location in signup queue. */
export declare namespace ComAtprotoTempCheckSignupQueue {
	interface Params {}
	type Input = undefined;
	interface Output {
		activated: boolean;
		placeInQueue?: number;
		estimatedTimeMs?: number;
	}
}

/** Fetch all labels from a labeler created after a certain date. DEPRECATED: use queryLabels or subscribeLabels instead */
export declare namespace ComAtprotoTempFetchLabels {
	interface Params {
		since?: number;
		/**
		 * Minimum: 1 \
		 * Maximum: 250
		 * @default 50
		 */
		limit?: number;
	}
	type Input = undefined;
	interface Output {
		labels: ComAtprotoLabelDefs.Label[];
	}
}

/** Request a verification code to be sent to the supplied phone number */
export declare namespace ComAtprotoTempRequestPhoneVerification {
	interface Params {}
	interface Input {
		phoneNumber: string;
	}
	type Output = undefined;
}

export declare interface Queries {
	'app.bsky.actor.getPreferences': {
		params: AppBskyActorGetPreferences.Params;
		output: AppBskyActorGetPreferences.Output;
	};
	'app.bsky.actor.getProfile': {
		params: AppBskyActorGetProfile.Params;
		output: AppBskyActorGetProfile.Output;
	};
	'app.bsky.actor.getProfiles': {
		params: AppBskyActorGetProfiles.Params;
		output: AppBskyActorGetProfiles.Output;
	};
	'app.bsky.actor.getSuggestions': {
		params: AppBskyActorGetSuggestions.Params;
		output: AppBskyActorGetSuggestions.Output;
	};
	'app.bsky.actor.searchActors': {
		params: AppBskyActorSearchActors.Params;
		output: AppBskyActorSearchActors.Output;
	};
	'app.bsky.actor.searchActorsTypeahead': {
		params: AppBskyActorSearchActorsTypeahead.Params;
		output: AppBskyActorSearchActorsTypeahead.Output;
	};
	'app.bsky.feed.describeFeedGenerator': {
		output: AppBskyFeedDescribeFeedGenerator.Output;
	};
	'app.bsky.feed.getActorFeeds': {
		params: AppBskyFeedGetActorFeeds.Params;
		output: AppBskyFeedGetActorFeeds.Output;
	};
	'app.bsky.feed.getActorLikes': {
		params: AppBskyFeedGetActorLikes.Params;
		output: AppBskyFeedGetActorLikes.Output;
	};
	'app.bsky.feed.getAuthorFeed': {
		params: AppBskyFeedGetAuthorFeed.Params;
		output: AppBskyFeedGetAuthorFeed.Output;
	};
	'app.bsky.feed.getFeed': {
		params: AppBskyFeedGetFeed.Params;
		output: AppBskyFeedGetFeed.Output;
	};
	'app.bsky.feed.getFeedGenerator': {
		params: AppBskyFeedGetFeedGenerator.Params;
		output: AppBskyFeedGetFeedGenerator.Output;
	};
	'app.bsky.feed.getFeedGenerators': {
		params: AppBskyFeedGetFeedGenerators.Params;
		output: AppBskyFeedGetFeedGenerators.Output;
	};
	'app.bsky.feed.getFeedSkeleton': {
		params: AppBskyFeedGetFeedSkeleton.Params;
		output: AppBskyFeedGetFeedSkeleton.Output;
	};
	'app.bsky.feed.getLikes': {
		params: AppBskyFeedGetLikes.Params;
		output: AppBskyFeedGetLikes.Output;
	};
	'app.bsky.feed.getListFeed': {
		params: AppBskyFeedGetListFeed.Params;
		output: AppBskyFeedGetListFeed.Output;
	};
	'app.bsky.feed.getPostThread': {
		params: AppBskyFeedGetPostThread.Params;
		output: AppBskyFeedGetPostThread.Output;
	};
	'app.bsky.feed.getPosts': {
		params: AppBskyFeedGetPosts.Params;
		output: AppBskyFeedGetPosts.Output;
	};
	'app.bsky.feed.getRepostedBy': {
		params: AppBskyFeedGetRepostedBy.Params;
		output: AppBskyFeedGetRepostedBy.Output;
	};
	'app.bsky.feed.getSuggestedFeeds': {
		params: AppBskyFeedGetSuggestedFeeds.Params;
		output: AppBskyFeedGetSuggestedFeeds.Output;
	};
	'app.bsky.feed.getTimeline': {
		params: AppBskyFeedGetTimeline.Params;
		output: AppBskyFeedGetTimeline.Output;
	};
	'app.bsky.feed.searchPosts': {
		params: AppBskyFeedSearchPosts.Params;
		output: AppBskyFeedSearchPosts.Output;
	};
	'app.bsky.graph.getBlocks': {
		params: AppBskyGraphGetBlocks.Params;
		output: AppBskyGraphGetBlocks.Output;
	};
	'app.bsky.graph.getFollowers': {
		params: AppBskyGraphGetFollowers.Params;
		output: AppBskyGraphGetFollowers.Output;
	};
	'app.bsky.graph.getFollows': {
		params: AppBskyGraphGetFollows.Params;
		output: AppBskyGraphGetFollows.Output;
	};
	'app.bsky.graph.getList': {
		params: AppBskyGraphGetList.Params;
		output: AppBskyGraphGetList.Output;
	};
	'app.bsky.graph.getListBlocks': {
		params: AppBskyGraphGetListBlocks.Params;
		output: AppBskyGraphGetListBlocks.Output;
	};
	'app.bsky.graph.getListMutes': {
		params: AppBskyGraphGetListMutes.Params;
		output: AppBskyGraphGetListMutes.Output;
	};
	'app.bsky.graph.getLists': {
		params: AppBskyGraphGetLists.Params;
		output: AppBskyGraphGetLists.Output;
	};
	'app.bsky.graph.getMutes': {
		params: AppBskyGraphGetMutes.Params;
		output: AppBskyGraphGetMutes.Output;
	};
	'app.bsky.graph.getRelationships': {
		params: AppBskyGraphGetRelationships.Params;
		output: AppBskyGraphGetRelationships.Output;
	};
	'app.bsky.graph.getSuggestedFollowsByActor': {
		params: AppBskyGraphGetSuggestedFollowsByActor.Params;
		output: AppBskyGraphGetSuggestedFollowsByActor.Output;
	};
	'app.bsky.notification.getUnreadCount': {
		params: AppBskyNotificationGetUnreadCount.Params;
		output: AppBskyNotificationGetUnreadCount.Output;
	};
	'app.bsky.notification.listNotifications': {
		params: AppBskyNotificationListNotifications.Params;
		output: AppBskyNotificationListNotifications.Output;
	};
	'app.bsky.unspecced.getPopularFeedGenerators': {
		params: AppBskyUnspeccedGetPopularFeedGenerators.Params;
		output: AppBskyUnspeccedGetPopularFeedGenerators.Output;
	};
	'app.bsky.unspecced.getTaggedSuggestions': {
		params: AppBskyUnspeccedGetTaggedSuggestions.Params;
		output: AppBskyUnspeccedGetTaggedSuggestions.Output;
	};
	'app.bsky.unspecced.searchActorsSkeleton': {
		params: AppBskyUnspeccedSearchActorsSkeleton.Params;
		output: AppBskyUnspeccedSearchActorsSkeleton.Output;
	};
	'app.bsky.unspecced.searchPostsSkeleton': {
		params: AppBskyUnspeccedSearchPostsSkeleton.Params;
		output: AppBskyUnspeccedSearchPostsSkeleton.Output;
	};
	'com.atproto.admin.getAccountInfo': {
		params: ComAtprotoAdminGetAccountInfo.Params;
		output: ComAtprotoAdminGetAccountInfo.Output;
	};
	'com.atproto.admin.getAccountInfos': {
		params: ComAtprotoAdminGetAccountInfos.Params;
		output: ComAtprotoAdminGetAccountInfos.Output;
	};
	'com.atproto.admin.getInviteCodes': {
		params: ComAtprotoAdminGetInviteCodes.Params;
		output: ComAtprotoAdminGetInviteCodes.Output;
	};
	'com.atproto.admin.getModerationEvent': {
		params: ComAtprotoAdminGetModerationEvent.Params;
		output: ComAtprotoAdminGetModerationEvent.Output;
	};
	'com.atproto.admin.getRecord': {
		params: ComAtprotoAdminGetRecord.Params;
		output: ComAtprotoAdminGetRecord.Output;
	};
	'com.atproto.admin.getRepo': {
		params: ComAtprotoAdminGetRepo.Params;
		output: ComAtprotoAdminGetRepo.Output;
	};
	'com.atproto.admin.getSubjectStatus': {
		params: ComAtprotoAdminGetSubjectStatus.Params;
		output: ComAtprotoAdminGetSubjectStatus.Output;
	};
	'com.atproto.admin.listCommunicationTemplates': {
		output: ComAtprotoAdminListCommunicationTemplates.Output;
	};
	'com.atproto.admin.queryModerationEvents': {
		params: ComAtprotoAdminQueryModerationEvents.Params;
		output: ComAtprotoAdminQueryModerationEvents.Output;
	};
	'com.atproto.admin.queryModerationStatuses': {
		params: ComAtprotoAdminQueryModerationStatuses.Params;
		output: ComAtprotoAdminQueryModerationStatuses.Output;
	};
	'com.atproto.admin.searchRepos': {
		params: ComAtprotoAdminSearchRepos.Params;
		output: ComAtprotoAdminSearchRepos.Output;
	};
	'com.atproto.identity.getRecommendedDidCredentials': {
		output: ComAtprotoIdentityGetRecommendedDidCredentials.Output;
	};
	'com.atproto.identity.resolveHandle': {
		params: ComAtprotoIdentityResolveHandle.Params;
		output: ComAtprotoIdentityResolveHandle.Output;
	};
	'com.atproto.label.queryLabels': {
		params: ComAtprotoLabelQueryLabels.Params;
		output: ComAtprotoLabelQueryLabels.Output;
	};
	'com.atproto.repo.describeRepo': {
		params: ComAtprotoRepoDescribeRepo.Params;
		output: ComAtprotoRepoDescribeRepo.Output;
	};
	'com.atproto.repo.getRecord': {
		params: ComAtprotoRepoGetRecord.Params;
		output: ComAtprotoRepoGetRecord.Output;
	};
	'com.atproto.repo.listMissingBlobs': {
		params: ComAtprotoRepoListMissingBlobs.Params;
		output: ComAtprotoRepoListMissingBlobs.Output;
	};
	'com.atproto.repo.listRecords': {
		params: ComAtprotoRepoListRecords.Params;
		output: ComAtprotoRepoListRecords.Output;
	};
	'com.atproto.server.checkAccountStatus': {
		output: ComAtprotoServerCheckAccountStatus.Output;
	};
	'com.atproto.server.describeServer': {
		output: ComAtprotoServerDescribeServer.Output;
	};
	'com.atproto.server.getAccountInviteCodes': {
		params: ComAtprotoServerGetAccountInviteCodes.Params;
		output: ComAtprotoServerGetAccountInviteCodes.Output;
	};
	'com.atproto.server.getServiceAuth': {
		params: ComAtprotoServerGetServiceAuth.Params;
		output: ComAtprotoServerGetServiceAuth.Output;
	};
	'com.atproto.server.getSession': {
		output: ComAtprotoServerGetSession.Output;
	};
	'com.atproto.server.listAppPasswords': {
		output: ComAtprotoServerListAppPasswords.Output;
	};
	'com.atproto.sync.getBlob': {
		params: ComAtprotoSyncGetBlob.Params;
		output: ComAtprotoSyncGetBlob.Output;
	};
	'com.atproto.sync.getBlocks': {
		params: ComAtprotoSyncGetBlocks.Params;
		output: ComAtprotoSyncGetBlocks.Output;
	};
	'com.atproto.sync.getCheckout': {
		params: ComAtprotoSyncGetCheckout.Params;
		output: ComAtprotoSyncGetCheckout.Output;
	};
	'com.atproto.sync.getHead': {
		params: ComAtprotoSyncGetHead.Params;
		output: ComAtprotoSyncGetHead.Output;
	};
	'com.atproto.sync.getLatestCommit': {
		params: ComAtprotoSyncGetLatestCommit.Params;
		output: ComAtprotoSyncGetLatestCommit.Output;
	};
	'com.atproto.sync.getRecord': {
		params: ComAtprotoSyncGetRecord.Params;
		output: ComAtprotoSyncGetRecord.Output;
	};
	'com.atproto.sync.getRepo': {
		params: ComAtprotoSyncGetRepo.Params;
		output: ComAtprotoSyncGetRepo.Output;
	};
	'com.atproto.sync.listBlobs': {
		params: ComAtprotoSyncListBlobs.Params;
		output: ComAtprotoSyncListBlobs.Output;
	};
	'com.atproto.sync.listRepos': {
		params: ComAtprotoSyncListRepos.Params;
		output: ComAtprotoSyncListRepos.Output;
	};
	'com.atproto.temp.checkSignupQueue': {
		output: ComAtprotoTempCheckSignupQueue.Output;
	};
	'com.atproto.temp.fetchLabels': {
		params: ComAtprotoTempFetchLabels.Params;
		output: ComAtprotoTempFetchLabels.Output;
	};
}

export declare interface Procedures {
	'app.bsky.actor.putPreferences': {
		input: AppBskyActorPutPreferences.Input;
	};
	'app.bsky.graph.muteActor': {
		input: AppBskyGraphMuteActor.Input;
	};
	'app.bsky.graph.muteActorList': {
		input: AppBskyGraphMuteActorList.Input;
	};
	'app.bsky.graph.unmuteActor': {
		input: AppBskyGraphUnmuteActor.Input;
	};
	'app.bsky.graph.unmuteActorList': {
		input: AppBskyGraphUnmuteActorList.Input;
	};
	'app.bsky.notification.registerPush': {
		input: AppBskyNotificationRegisterPush.Input;
	};
	'app.bsky.notification.updateSeen': {
		input: AppBskyNotificationUpdateSeen.Input;
	};
	'com.atproto.admin.createCommunicationTemplate': {
		input: ComAtprotoAdminCreateCommunicationTemplate.Input;
		output: ComAtprotoAdminCreateCommunicationTemplate.Output;
	};
	'com.atproto.admin.deleteAccount': {
		input: ComAtprotoAdminDeleteAccount.Input;
	};
	'com.atproto.admin.deleteCommunicationTemplate': {
		input: ComAtprotoAdminDeleteCommunicationTemplate.Input;
	};
	'com.atproto.admin.disableAccountInvites': {
		input: ComAtprotoAdminDisableAccountInvites.Input;
	};
	'com.atproto.admin.disableInviteCodes': {
		input: ComAtprotoAdminDisableInviteCodes.Input;
	};
	'com.atproto.admin.emitModerationEvent': {
		input: ComAtprotoAdminEmitModerationEvent.Input;
		output: ComAtprotoAdminEmitModerationEvent.Output;
	};
	'com.atproto.admin.enableAccountInvites': {
		input: ComAtprotoAdminEnableAccountInvites.Input;
	};
	'com.atproto.admin.sendEmail': {
		input: ComAtprotoAdminSendEmail.Input;
		output: ComAtprotoAdminSendEmail.Output;
	};
	'com.atproto.admin.updateAccountEmail': {
		input: ComAtprotoAdminUpdateAccountEmail.Input;
	};
	'com.atproto.admin.updateAccountHandle': {
		input: ComAtprotoAdminUpdateAccountHandle.Input;
	};
	'com.atproto.admin.updateAccountPassword': {
		input: ComAtprotoAdminUpdateAccountPassword.Input;
	};
	'com.atproto.admin.updateCommunicationTemplate': {
		input: ComAtprotoAdminUpdateCommunicationTemplate.Input;
		output: ComAtprotoAdminUpdateCommunicationTemplate.Output;
	};
	'com.atproto.admin.updateSubjectStatus': {
		input: ComAtprotoAdminUpdateSubjectStatus.Input;
		output: ComAtprotoAdminUpdateSubjectStatus.Output;
	};
	'com.atproto.identity.requestPlcOperationSignature': {};
	'com.atproto.identity.signPlcOperation': {
		input: ComAtprotoIdentitySignPlcOperation.Input;
		output: ComAtprotoIdentitySignPlcOperation.Output;
	};
	'com.atproto.identity.submitPlcOperation': {
		input: ComAtprotoIdentitySubmitPlcOperation.Input;
	};
	'com.atproto.identity.updateHandle': {
		input: ComAtprotoIdentityUpdateHandle.Input;
	};
	'com.atproto.moderation.createReport': {
		input: ComAtprotoModerationCreateReport.Input;
		output: ComAtprotoModerationCreateReport.Output;
	};
	'com.atproto.repo.applyWrites': {
		input: ComAtprotoRepoApplyWrites.Input;
	};
	'com.atproto.repo.createRecord': {
		input: ComAtprotoRepoCreateRecord.Input;
		output: ComAtprotoRepoCreateRecord.Output;
	};
	'com.atproto.repo.deleteRecord': {
		input: ComAtprotoRepoDeleteRecord.Input;
	};
	'com.atproto.repo.importRepo': {
		input: ComAtprotoRepoImportRepo.Input;
	};
	'com.atproto.repo.putRecord': {
		input: ComAtprotoRepoPutRecord.Input;
		output: ComAtprotoRepoPutRecord.Output;
	};
	'com.atproto.repo.uploadBlob': {
		input: ComAtprotoRepoUploadBlob.Input;
		output: ComAtprotoRepoUploadBlob.Output;
	};
	'com.atproto.server.activateAccount': {};
	'com.atproto.server.confirmEmail': {
		input: ComAtprotoServerConfirmEmail.Input;
	};
	'com.atproto.server.createAccount': {
		input: ComAtprotoServerCreateAccount.Input;
		output: ComAtprotoServerCreateAccount.Output;
	};
	'com.atproto.server.createAppPassword': {
		input: ComAtprotoServerCreateAppPassword.Input;
		output: ComAtprotoServerCreateAppPassword.Output;
	};
	'com.atproto.server.createInviteCode': {
		input: ComAtprotoServerCreateInviteCode.Input;
		output: ComAtprotoServerCreateInviteCode.Output;
	};
	'com.atproto.server.createInviteCodes': {
		input: ComAtprotoServerCreateInviteCodes.Input;
		output: ComAtprotoServerCreateInviteCodes.Output;
	};
	'com.atproto.server.createSession': {
		input: ComAtprotoServerCreateSession.Input;
		output: ComAtprotoServerCreateSession.Output;
	};
	'com.atproto.server.deactivateAccount': {
		input: ComAtprotoServerDeactivateAccount.Input;
	};
	'com.atproto.server.deleteAccount': {
		input: ComAtprotoServerDeleteAccount.Input;
	};
	'com.atproto.server.deleteSession': {};
	'com.atproto.server.refreshSession': {
		output: ComAtprotoServerRefreshSession.Output;
	};
	'com.atproto.server.requestAccountDelete': {};
	'com.atproto.server.requestEmailConfirmation': {};
	'com.atproto.server.requestEmailUpdate': {
		output: ComAtprotoServerRequestEmailUpdate.Output;
	};
	'com.atproto.server.requestPasswordReset': {
		input: ComAtprotoServerRequestPasswordReset.Input;
	};
	'com.atproto.server.reserveSigningKey': {
		input: ComAtprotoServerReserveSigningKey.Input;
		output: ComAtprotoServerReserveSigningKey.Output;
	};
	'com.atproto.server.resetPassword': {
		input: ComAtprotoServerResetPassword.Input;
	};
	'com.atproto.server.revokeAppPassword': {
		input: ComAtprotoServerRevokeAppPassword.Input;
	};
	'com.atproto.server.updateEmail': {
		input: ComAtprotoServerUpdateEmail.Input;
	};
	'com.atproto.sync.notifyOfUpdate': {
		input: ComAtprotoSyncNotifyOfUpdate.Input;
	};
	'com.atproto.sync.requestCrawl': {
		input: ComAtprotoSyncRequestCrawl.Input;
	};
	'com.atproto.temp.requestPhoneVerification': {
		input: ComAtprotoTempRequestPhoneVerification.Input;
	};
}
